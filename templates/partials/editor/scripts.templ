package editor

import (
	"context"
	"law_flow_app_go/models"
)

templ Scripts(ctx context.Context, template models.DocumentTemplate) {
	<!-- Hidden Form for Save -->
	<form id="save-template-form" hx-put={ "/api/templates/" + template.ID } hx-target="body" class="hidden">
		<input type="hidden" name="content" id="hidden-content-input"/>
		<input type="hidden" name="name" value={ template.Name }/>
	</form>
	<script>
		function templateEditor(configuredPageHeight = 1056) {
			return {
				// Context Menu
				showContextMenu: false,
				contextMenuX: 0,
				contextMenuY: 0,
				variables: [],

				// Formatting State
				isBold: false,
				isItalic: false,
				isUnderline: false,
				alignment: 'left',

				// View Mode & Page Dimensions
				viewMode: 'paginated',
				pageHeight: configuredPageHeight, // Height based on document type
				pageWidth: configuredPageHeight === 1123 ? 794 : 816, // A4 vs Letter/Legal width
				pageGap: 32, // Gap between pages in pixels
				pagePadding: 96, // 72pt â‰ˆ 96px at 96dpi
				currentPage: 1,
				totalPages: 1,

				get contextMenuStyle() {
					return `top: ${this.contextMenuY}px; left: ${this.contextMenuX}px`;
				},

				init() {
					// Load variables
					this.loadVariables();

					// Listen for selection changes to update formatting state
					document.addEventListener('selectionchange', () => this.updateFormattingState());

					// Initial page count
					this.$nextTick(() => {
						this.updatePageCount();
					});
				},

				// Handle input events
				handleInput() {
					this.updatePageCount();
				},

				async loadVariables() {
					try {
						const response = await fetch('/api/templates/variables');
						this.variables = await response.json();
					} catch (e) {
						console.error('Failed to load variables:', e);
					}
				},

				openContextMenu(event) {
					const menuWidth = 256;
					const menuHeight = 320;
					const padding = 10;

					let x = event.clientX;
					let y = event.clientY;

					// Adjust if would overflow right
					if (x + menuWidth + padding > window.innerWidth) {
						x = window.innerWidth - menuWidth - padding;
					}

					// Adjust if would overflow bottom
					if (y + menuHeight + padding > window.innerHeight) {
						y = window.innerHeight - menuHeight - padding;
					}

					// Ensure not negative
					x = Math.max(padding, x);
					y = Math.max(padding, y);

					this.contextMenuX = x;
					this.contextMenuY = y;
					this.showContextMenu = true;
				},

				insertVariable(tag) {
					document.execCommand("insertText", false, "{{ " + tag + " }}");
					this.showContextMenu = false;
				},

				execCommand(command) {
					document.execCommand(command, false, null);
					this.updateFormattingState();
				},

				updateFormattingState() {
					this.isBold = document.queryCommandState('bold');
					this.isItalic = document.queryCommandState('italic');
					this.isUnderline = document.queryCommandState('underline');

					// Check alignment
					if (document.queryCommandState('justifyLeft')) {
						this.alignment = 'left';
					} else if (document.queryCommandState('justifyCenter')) {
						this.alignment = 'center';
					} else if (document.queryCommandState('justifyRight')) {
						this.alignment = 'right';
					} else if (document.queryCommandState('justifyFull')) {
						this.alignment = 'justify';
					}
				},

				insertPageBreak() {
					const pageBreak = '<div class="page-break" style="page-break-after: always; border-top: 4px dashed #bbb; margin: 60px 0; position: relative;"><span style="position: absolute; top: -14px; left: 50%; transform: translateX(-50%); background: white; padding: 0 10px; color: #999; font-size: 11px;">Page Break</span></div><p><br></p>';
					document.execCommand('insertHTML', false, pageBreak);
					this.updatePageCount();
				},

				handleKeydown(event) {
					// Ctrl+Enter for page break
					if (event.ctrlKey && event.key === 'Enter') {
						event.preventDefault();
						this.insertPageBreak();
					}
				},

				updatePageCount() {
					const editor = document.getElementById('editor-content');
					if (!editor) return;

					const contentHeight = editor.scrollHeight;
					// Account for page gaps in calculation
					const effectivePageHeight = this.pageHeight + this.pageGap;
					this.totalPages = Math.max(1, Math.ceil(contentHeight / effectivePageHeight));
				},

				updateCurrentPage() {
					const scroller = document.getElementById('editor-scroller');
					if (!scroller) return;

					const scrollTop = scroller.scrollTop;
					const effectivePageHeight = this.pageHeight + this.pageGap;
					// Calculate based on the center of the viewport
					const middle = scrollTop + (scroller.clientHeight / 3);
					this.currentPage = Math.max(1, Math.min(
						this.totalPages,
						Math.floor(middle / effectivePageHeight) + 1
					));
				}
			};
		}

		function saveTemplateContent() {
			const editor = document.getElementById('editor-content');
			if (!editor) return;

			const content = editor.innerHTML;
			document.getElementById('hidden-content-input').value = content;
			htmx.trigger('#save-template-form', 'submit');
		}
	</script>
}

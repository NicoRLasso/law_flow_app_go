package partials

import (
	"context"
	"encoding/json"
	"fmt"
	"law_flow_app_go/models"
	"law_flow_app_go/services/i18n"
	"law_flow_app_go/templates/components"
	"strings"
)

templ AuditLogTable(ctx context.Context, logs []models.AuditLog, total int64, page, pageSize int) {
	if len(logs) == 0 {
		<div class="text-center py-16 bg-base-50">
			<div class="w-16 h-16 mx-auto mb-4 rounded-full bg-base-200 flex items-center justify-center text-base-content/40">
				<i data-lucide="history" class="text-2xl"></i>
			</div>
			<p class="font-serif italic text-base-content/60">{ i18n.T(ctx, "audit.noLogs") }</p>
		</div>
	} else {
		<div class="overflow-x-auto">
			<table class="table w-full">
				<thead>
					<tr class="bg-base-200/50 border-b border-base-200 text-base-content/70">
						<th class="font-serif font-bold uppercase tracking-wider">{ i18n.T(ctx, "audit.table.timestamp") }</th>
						<th class="font-serif font-bold uppercase tracking-wider">{ i18n.T(ctx, "audit.table.user") }</th>
						<th class="font-serif font-bold uppercase tracking-wider">{ i18n.T(ctx, "audit.table.action") }</th>
						<th class="font-serif font-bold uppercase tracking-wider">{ i18n.T(ctx, "audit.table.resource") }</th>
						<th class="font-serif font-bold uppercase tracking-wider">{ i18n.T(ctx, "audit.table.description") }</th>
						<th class="font-serif font-bold uppercase tracking-wider">{ i18n.T(ctx, "audit.table.details") }</th>
					</tr>
				</thead>
				<tbody>
					for _, log := range logs {
						<tr class="hover group">
							<td class="font-mono text-sm text-base-content/70">
								{ log.CreatedAt.Format("2006-01-02 15:04:05") }
							</td>
							<td>
								<div class="font-semibold text-base-content">{ log.UserName }</div>
								<div class="text-xs text-base-content/50">{ log.UserRole }</div>
							</td>
							<td>
								@actionBadge(ctx, log.Action)
							</td>
							<td>
								<div class="text-sm font-medium text-base-content">{ i18n.T(ctx, getResourceKey(log.ResourceType)) }</div>
								<div class="text-xs text-base-content/50 truncate max-w-[150px]" title={ log.ResourceName }>{ log.ResourceName }</div>
							</td>
							<td class="text-sm text-base-content/70 max-w-xs truncate" title={ log.Description }>
								{ log.Description }
							</td>
							<td>
								if (log.Action == models.AuditActionUpdate || log.Action == models.AuditActionVisibilityChange) && (log.OldValues != "" || log.NewValues != "") {
									<div x-data="{ open: false }">
										<button
											class="btn btn-xs btn-primary text-primary"
											@click="open = true"
										>
											{ i18n.T(ctx, "audit.viewChanges") }
										</button>
										<!-- Changes Modal -->
										<div
											x-show="open"
											class="fixed inset-0 z-50 flex items-center justify-center p-4 bg-base-300/80 backdrop-blur-sm"
											style="display: none;"
										>
											<div class="bg-base-100 w-full max-w-4xl rounded-sm shadow-2xl border border-base-200 overflow-hidden flex flex-col max-h-[90vh]" @click.away="open = false">
												<div class="p-6 border-b border-base-200 flex justify-between items-center">
													<h3 class="text-lg font-serif font-bold text-base-content">
														{ i18n.T(ctx, "audit.changeDetails") }
													</h3>
													<button @click="open = false" class="btn btn-sm btn-primary btn-square">
														<i data-lucide="x"></i>
													</button>
												</div>
												<div class="p-6 overflow-y-auto">
													<table class="table w-full text-sm border border-base-200">
														<thead class="bg-base-200/50">
															<tr>
																<th class="w-1/5 border-b border-base-200">{ i18n.T(ctx, "audit.diff.field") }</th>
																<th class="w-2/5 border-b border-base-200">{ i18n.T(ctx, "audit.diff.old") }</th>
																<th class="w-2/5 border-b border-base-200">{ i18n.T(ctx, "audit.diff.new") }</th>
															</tr>
														</thead>
														<tbody>
															for _, change := range log.Changes() {
																<tr class="hover">
																	<td class="font-mono text-xs font-bold bg-base-100">{ change.Field }</td>
																	<td class="bg-error/5 text-base-content/80 font-mono text-xs break-all">
																		<pre class="whitespace-pre-wrap">{ formatAuditValue(change.Old) }</pre>
																	</td>
																	<td class="bg-success/5 text-base-content/80 font-mono text-xs break-all">
																		<pre class="whitespace-pre-wrap">{ formatAuditValue(change.New) }</pre>
																	</td>
																</tr>
															}
														</tbody>
													</table>
												</div>
												<div class="p-4 bg-base-100 border-t border-base-200 flex justify-end">
													<button type="button" class="btn btn-primary rounded-sm" @click="open = false">
														{ i18n.T(ctx, "common.close") }
													</button>
												</div>
											</div>
										</div>
									</div>
								}
							</td>
						</tr>
					}
				</tbody>
			</table>
		</div>
		<!-- Pagination -->
		<div class="p-4 border-t border-base-200">
			@components.Pagination(ctx, components.PaginationData{
				CurrentPage: page,
				TotalPages:  (int(total) + pageSize - 1) / pageSize,
				Limit:       pageSize,
				Total:       int(total),
				BaseURL:     "/api/audit-logs",
				TargetID:    "#audit-logs-table",
				IncludeID:   "#filter-form",
			})
		</div>
	}
}

templ actionBadge(ctx context.Context, action models.AuditAction) {
	switch action {
		case models.AuditActionCreate:
			<span class="badge badge-success badge-sm text-white">{ i18n.T(ctx, "audit.actions.create") }</span>
		case models.AuditActionUpdate:
			<span class="badge badge-info badge-sm text-white">{ i18n.T(ctx, "audit.actions.update") }</span>
		case models.AuditActionDelete:
			<span class="badge badge-error badge-sm text-white">{ i18n.T(ctx, "audit.actions.delete") }</span>
		case models.AuditActionView:
			<span class="badge badge-ghost badge-sm">{ i18n.T(ctx, "audit.actions.view") }</span>
		case models.AuditActionDownload:
			<span class="badge badge-accent badge-sm text-white">{ i18n.T(ctx, "audit.actions.download") }</span>
		case models.AuditActionVisibilityChange:
			<span class="badge badge-secondary badge-sm text-white">{ i18n.T(ctx, "audit.actions.visibility") }</span>
		case "LOGIN":
			<span class="badge badge-success badge-sm badge-outline">LOGIN</span>
		case "LOGOUT":
			<span class="badge badge-warning badge-sm badge-outline">LOGOUT</span>
		default:
			<span class="badge badge-ghost badge-sm">{ string(action) }</span>
	}
}

func getResourceKey(resourceType string) string {
	switch resourceType {
	case "BlockedDate":
		return "audit.resources.blocked_date"
	case "CaseRequest":
		return "audit.resources.case_request"
	case "CaseDocument":
		return "audit.resources.document"
	case "GeneratedDocument":
		return "audit.resources.generated_document"
	case "AppointmentType":
		return "audit.resources.appointment_type"
	case "Case":
		return "audit.resources.case"
	case "User":
		return "audit.resources.user"
	case "Appointment":
		return "audit.resources.appointment"
	case "Availability":
		return "audit.resources.availability"
	case "Firm":
		return "audit.resources.firm"
	case "Template":
		return "audit.resources.template"
	default:
		return "audit.resources." + resourceType
	}
}

func formatAuditValue(v interface{}) string {
	if v == nil {
		return "-"
	}

	// Handle slice of things (like subtypes list)
	if slice, ok := v.([]interface{}); ok {
		var items []string
		for _, item := range slice {
			str := formatAuditValue(item)
			if str != "" && str != "-" {
				items = append(items, str)
			}
		}
		if len(items) > 0 {
			return strings.Join(items, ", ")
		}
		return ""
	}

	// Handle maps (objects) - try to find a readable name
	if m, ok := v.(map[string]interface{}); ok {
		// Priority list of fields to represent the object
		keys := []string{"name", "title", "description", "code", "username", "email", "id"}
		for _, k := range keys {
			if val, ok := m[k].(string); ok && val != "" {
				return val
			}
		}

		b, _ := json.MarshalIndent(v, "", "  ")
		return string(b)
	}

	// Default formatting logic
	switch val := v.(type) {
	case string:
		return val
	case float64:
		// JSON numbers are float64, check if it's actually an integer
		if val == float64(int64(val)) {
			return fmt.Sprintf("%d", int64(val))
		}
		return fmt.Sprintf("%g", val)
	case bool:
		if val {
			return "Yes"
		}
		return "No"
	default:
		// Try JSON marshal for any other complex types not caught above
		b, err := json.MarshalIndent(v, "", "  ")
		if err == nil {
			return string(b)
		}
		return fmt.Sprintf("%v", v)
	}
}

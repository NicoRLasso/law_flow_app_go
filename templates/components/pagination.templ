package components

import (
	"context"
	"fmt"
	"law_flow_app_go/services/i18n"
)

// PaginationData holds pagination information
type PaginationData struct {
	CurrentPage int
	TotalPages  int
	Limit       int
	Total       int
	BaseURL     string
	Status      string
	Priority    string
}

// Pagination renders pagination controls
templ Pagination(ctx context.Context, data PaginationData) {
	if data.TotalPages > 1 {
		<div class="flex items-center justify-between mt-6 px-4 py-3 glass-panel rounded-xl border border-white/10">
			<!-- Pagination Info -->
			<div class="text-sm text-muted-foreground">
				{ i18n.T(ctx, "common.pagination.showing", map[string]interface{}{
					"start": fmt.Sprintf("%d", (data.CurrentPage-1)*data.Limit+1),
					"end":   fmt.Sprintf("%d", min(data.CurrentPage*data.Limit, data.Total)),
					"total": fmt.Sprintf("%d", data.Total),
				}) }
			</div>
			
			<!-- Pagination Controls -->
			<div class="flex items-center gap-2">
				<!-- Previous Button -->
				if data.CurrentPage > 1 {
					<button
						hx-get={ buildPaginationURL(data.BaseURL, data.CurrentPage-1, data.Status, data.Priority) }
						hx-target="#case-requests-list"
						hx-swap="innerHTML"
						class="px-3 py-2 rounded-lg bg-white/5 text-foreground hover:bg-white/10 transition-all duration-200 text-sm font-medium"
					>
						{ i18n.T(ctx, "common.pagination.previous") }
					</button>
				} else {
					<button
						disabled
						class="px-3 py-2 rounded-lg bg-white/5 text-muted-foreground cursor-not-allowed text-sm font-medium opacity-50"
					>
						{ i18n.T(ctx, "common.pagination.previous") }
					</button>
				}
				
				<!-- Page Numbers -->
				<div class="flex items-center gap-1">
					for _, pageNum := range getPaginationRange(data.CurrentPage, data.TotalPages) {
						if pageNum == -1 {
							<span class="px-2 text-muted-foreground">...</span>
						} else if pageNum == data.CurrentPage {
							<button
								class="px-3 py-2 rounded-lg bg-accent text-accent-foreground font-semibold text-sm min-w-[40px]"
							>
								{ fmt.Sprintf("%d", pageNum) }
							</button>
						} else {
							<button
								hx-get={ buildPaginationURL(data.BaseURL, pageNum, data.Status, data.Priority) }
								hx-target="#case-requests-list"
								hx-swap="innerHTML"
								class="px-3 py-2 rounded-lg bg-white/5 text-foreground hover:bg-white/10 transition-all duration-200 text-sm font-medium min-w-[40px]"
							>
								{ fmt.Sprintf("%d", pageNum) }
							</button>
						}
					}
				</div>
				
				<!-- Next Button -->
				if data.CurrentPage < data.TotalPages {
					<button
						hx-get={ buildPaginationURL(data.BaseURL, data.CurrentPage+1, data.Status, data.Priority) }
						hx-target="#case-requests-list"
						hx-swap="innerHTML"
						class="px-3 py-2 rounded-lg bg-white/5 text-foreground hover:bg-white/10 transition-all duration-200 text-sm font-medium"
					>
						{ i18n.T(ctx, "common.pagination.next") }
					</button>
				} else {
					<button
						disabled
						class="px-3 py-2 rounded-lg bg-white/5 text-muted-foreground cursor-not-allowed text-sm font-medium opacity-50"
					>
						{ i18n.T(ctx, "common.pagination.next") }
					</button>
				}
			</div>
		</div>
	}
}

// Helper function to build pagination URL with filters
func buildPaginationURL(baseURL string, page int, status string, priority string) string {
	url := fmt.Sprintf("%s?page=%d", baseURL, page)
	if status != "" {
		url += fmt.Sprintf("&status=%s", status)
	}
	if priority != "" {
		url += fmt.Sprintf("&priority=%s", priority)
	}
	return url
}

// Helper function to get pagination range with ellipsis
func getPaginationRange(current, total int) []int {
	if total <= 7 {
		// Show all pages if 7 or fewer
		pages := make([]int, total)
		for i := 0; i < total; i++ {
			pages[i] = i + 1
		}
		return pages
	}

	// Always show first page, last page, current page, and 2 pages around current
	pages := []int{}
	
	// First page
	pages = append(pages, 1)
	
	// Add ellipsis if needed
	if current > 3 {
		pages = append(pages, -1) // -1 represents ellipsis
	}
	
	// Pages around current
	start := max(2, current-1)
	end := min(total-1, current+1)
	for i := start; i <= end; i++ {
		pages = append(pages, i)
	}
	
	// Add ellipsis if needed
	if current < total-2 {
		pages = append(pages, -1)
	}
	
	// Last page
	pages = append(pages, total)
	
	return pages
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
